/*
  +--------------------------------------------------------------------------+
  | Zephir Library                                                           |
  | Copyright (c) 2013-2018 Zephir Team (https://zephir-lang.com/)           |
  |                                                                          |
  | This source file is subject the MIT license, that is bundled with this   |
  | package in the file LICENSE, and is available through the world-wide-web |
  | at the following url: https://zephir-lang.com/license.html               |
  +--------------------------------------------------------------------------+
*/

%token_prefix XX_
%token_type {xx_parser_token*}
%default_type {json_object*}
%extra_argument {xx_parser_status *status}
%name xx_

%left INTERNAL PUBLIC PROTECTED STATIC PRIVATE SCOPED .
%left COMMA .
%right REQUIRE .
%right DOUBLEARROW .
%right QUESTION .
%right LIKELY UNLIKELY .
%left OR .
%left AND .
%left INSTANCEOF .
%left BITWISE_OR BITWISE_XOR BITWISE_SHIFTLEFT BITWISE_SHIFTRIGHT .
%left EQUALS IDENTICAL LESS GREATER LESSEQUAL GREATEREQUAL NOTIDENTICAL NOTEQUALS .
%left ADD SUB CONCAT .
%left MUL DIV MOD .
%right ISSET FETCH EMPTY .
%left INCLUSIVE_RANGE EXCLUSIVE_RANGE .
%right TYPEOF .
%right CLONE .
%right NEW .
%right NOT .
%right BITWISE_NOT .
%left BITWISE_AND .
%right PARENTHESES_CLOSE .
%right SBRACKET_OPEN .
%right ARROW .

%include {
#include "libzephir.h"
#include "lemon.inc.h"
}

%syntax_error {
	json_object *syntax_error = json_object_new_object();

	json_object_object_add(syntax_error, "type", json_object_new_string("error"));

	if (status->scanner_state->start_length) {
		json_object_object_add(syntax_error, "message", json_object_new_string("Syntax error"));
	} else {
		json_object_object_add(syntax_error, "message", json_object_new_string("Unexpected EOF"));
	}

	json_object_object_add(syntax_error, "file", json_object_new_string(status->scanner_state->active_file));
	json_object_object_add(syntax_error, "line", json_object_new_int(status->scanner_state->active_line));
	json_object_object_add(syntax_error, "char", json_object_new_int(status->scanner_state->active_char));

	status->status = XX_PARSING_FAILED;
	status->ret = syntax_error;
}

%token_destructor {
	if ($$) {
		if ($$->free_flag) {
			free($$->token);
		}
	}
}

program ::= xx_language(Q) . {
	status->ret = Q;
}

%destructor xx_language {
	json_object_put($$);
}

xx_language(R) ::= xx_top_statement_list(L) . {
	R = L;
}

xx_top_statement_list(R) ::= xx_top_statement_list(L) xx_top_statement(T) . {
	R = xx_ret_list(L, T);
}

xx_top_statement_list(R) ::= xx_top_statement(T) . {
	R = xx_ret_list(NULL, T);
}

xx_top_statement(R) ::= xx_namespace_def(T) . {
	R = T;
}

xx_top_statement(R) ::= xx_use_aliases(T) . {
	R = T;
}

xx_namespace_def(R) ::= NAMESPACE IDENTIFIER(I) DOTCOMMA . {
	R = xx_ret_namespace(I, status->scanner_state);
}

xx_namespace_def(R) ::= USE xx_use_aliases_list(L) DOTCOMMA . {
	R = xx_ret_use_aliases(L, status->scanner_state);
}

// FIXME: Does not work
xx_use_aliases_list(R) ::= xx_use_aliases_list(L) COMMA xx_use_aliases(U) . {
	R = xx_ret_list(L, U);
}

xx_use_aliases_list(R) ::= xx_use_aliases(U) . {
	R = xx_ret_list(NULL, U);
}

xx_use_aliases(R) ::= IDENTIFIER(I) . {
	R = xx_ret_use_aliases_item(I, NULL, status->scanner_state);
}

xx_use_aliases(R) ::= IDENTIFIER(I) AS IDENTIFIER(A) . {
	R = xx_ret_use_aliases_item(I, A, status->scanner_state);
}

/*
 * Local variables:
 * mode: lemon-c
 * End:
 */
