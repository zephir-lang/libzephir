/*
+--------------------------------------------------------------------------+
| Zephir Library                                                           |
| Copyright (c) 2013-2018 Zephir Team (https://zephir-lang.com/)           |
|                                                                          |
| This source file is subject the MIT license, that is bundled with this   |
| package in the file LICENSE, and is available through the world-wide-web |
| at the following url: https://zephir-lang.com/license.html               |
+--------------------------------------------------------------------------+
*/

%token_prefix XX_
%token_type {xx_parser_token*}
%default_type {json_object*}
%extra_argument {xx_parser_status *status}
%name xx_

%left INTERNAL PUBLIC PROTECTED STATIC PRIVATE SCOPED .
%left COMMA .
%right REQUIRE .
%right DOUBLEARROW .
%right QUESTION .
%right LIKELY UNLIKELY .
%left OR .
%left AND .
%left INSTANCEOF .
%left BITWISE_OR BITWISE_XOR BITWISE_SHIFTLEFT BITWISE_SHIFTRIGHT .
%left EQUALS IDENTICAL LESS GREATER LESSEQUAL GREATEREQUAL NOTIDENTICAL NOTEQUALS .
%left ADD SUB CONCAT .
%left MUL DIV MOD .
%right ISSET FETCH EMPTY .
%left INCLUSIVE_RANGE EXCLUSIVE_RANGE .
%right TYPEOF .
%right CLONE .
%right NEW .
%right NOT .
%right BITWISE_NOT .
%left BITWISE_AND .
%right PARENTHESES_CLOSE .
%right SBRACKET_OPEN .
%right ARROW .

%include {
#include "libzephir.h"
#include "lemon.inc.h"
}

%syntax_error {
  json_object *syntax_error = json_object_new_object();

  json_object_object_add(syntax_error, "type", json_object_new_string("error"));

  if (status->scanner_state->start_length) {
    json_object_object_add(syntax_error, "message", json_object_new_string("Syntax error"));
  } else {
    json_object_object_add(syntax_error, "message", json_object_new_string("Unexpected EOF"));
  }

  json_object_object_add(syntax_error, "file", json_object_new_string(status->scanner_state->active_file));
	json_object_object_add(syntax_error, "line", json_object_new_int(status->scanner_state->active_line));
	json_object_object_add(syntax_error, "char", json_object_new_int(status->scanner_state->active_char));

	status->status = XX_PARSING_FAILED;
	status->ret = syntax_error;
}

%token_destructor {
  if ($$) {
    if ($$->free_flag) {
      free($$->token);
    }
  }
}

program ::= xx_language(Q) . {
  status->ret = Q;
}

%destructor xx_language {
  json_object_put($$);
}

xx_language(R) ::= xx_top_statement_list(L) . {
	R = L;
}

xx_top_statement_list(R) ::= xx_top_statement_list(L) xx_top_statement(T) . {
	R = xx_ret_list(L, T);
}

xx_top_statement_list(R) ::= xx_top_statement(T) . {
	R = xx_ret_list(NULL, T);
}

xx_top_statement(R) ::= xx_namespace_def(T) . {
	R = T;
}

xx_namespace_def(R) ::= NAMESPACE IDENTIFIER(I) DOTCOMMA . {
	R = xx_ret_namespace(I, status->scanner_state);
}

/*
 * Local variables:
 * mode: lemon-c
 * End:
 */
